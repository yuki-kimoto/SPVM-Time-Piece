# Copyright (c) 2023 Yuki Kimoto
# MIT License

class Time::Piece {
  version "0.001";
  
  use Time::Seconds;
  use Time::Local;
  use Sys::Time::Tm;
  use Math;
  
  # Class Variables
  our $DATE_SEP : string;
  our $TIME_SEP : string;
  our $MON_LIST : string[];
  our $FULLMON_LIST : string[];
  our $DAY_LIST : string[];
  our $FULLDAY_LIST : string[];
  
  our $LOCALE : string[];
  
  # Fields
  has epoch : long;
  
  has islocal : byte;
  
  has tm : Sys::Time::Tm;
  
  INIT {
    $DATE_SEP = "-";
    $TIME_SEP = ":";
    $MON_LIST = ["Jan", "Feb", "Mar", "Apr", "May", "Jun", "Jul", "Aug", "Sep", "Oct", "Nov", "Dec"];
    $FULLMON_LIST = ["January", "February", "March", "April", "May", "June", "July", 
                      "August", "September", "October", "November", "December"];
    $DAY_LIST = ["Sun", "Mon", "Tue", "Wed", "Thu", "Fri", "Sat"];
    $FULLDAY_LIST = ["Sunday", "Monday", "Tuesday", "Wednesday", "Thursday", "Friday", "Saturday"];
  }
  
  method localtime ($time : long = -1) {
    
    if ($time < 0) {
      $time = Sys->time;
    }
    
    return &_mktime($time, 1);
  }
  
  method gmtime  {
    
    if ($time < 0) {
      $time = Sys->time;
    }
    
    return &_mktime($time, 0);
  }
  
  method _mktime : Time::Piece ($time : long, $islocal : int) {
    
    Sys::Time->tzset;
    
    my $new_tp = new Time::Piece;
    
    my $new_tm = (Time::Piece)undef;
    if ($islocal) {
      $new_tm = Sys->localtime($time);
    }
    else {
      $new_tm = Sys->gmtime($time);
    }
    
    $new_tm->{tm} = $new_tm;
    
    $new_tm->{epoch} = $time;
    
    $new_tm->{islocal} = $islocal;
    
    return $new_tp;
  }
  
  # Instance Methods
  method sec : int () {
    
    $self->{tm}{tm_sec};
  }
  
  method second : int () {
    
    return $self->sec;
  }
  
  method min : int {
    
    return $self->{tm}{tm_min};
  }
  
  method minute : int {
    
    return $self->{tm}{tm_minute};
  }
  
  method hour : int {
    
    return $self->{tm}{tm_hour};
  }
  
  method mday : int {
    
    return $self->{tm}{tm_mday};
  }
  
  method day_of_month : int {
    
    return $self->mday;
  }
  
  method mon : int {
    
    return $self->{tm}{tm_mon} + 1;
  }
  
  method _mon : int {
    
    return $self->{tm}{tm_mon};
  }
  
  method month : string ($mon_list : string[] = undef) {
    
    if ($mon_list) {
      return $mon_list->[$self->{tm}{tm_mon}];
    }
    else {
      return $MON_LIST->[$self->{tm}{tm_mon}];
    }
  }
  
  method month : string ($mon_list : string[] = undef) {
    
    return &month($mon_list);
  }
  
  method fullmonth : string ($mon_list : string[] = undef) {
      
    if ($mon_list) {
      return $mon_list->[$self->{tm}{tm_mon}];
    }
    else {
      return $FULLMON_LIST->[$self->{tm}{tm_mon}];
    }
  }
  
  method year : int () {
    
    return $self->{tm}{tm_year} + 1900;
  }
  
  method _year : int () {
    
    return $self->{tm}{tm_year};
  }
  
  method yy : string () {
    
    my $res = $self->{tm}{tm_year} % 100;
    
    my $res_string = (string)undef;
    if ($res > 9) {
      $res_string = "$res";
    }
    else {
      $res_string = "0$res";
    }
    
    return $res_string;
  }
  
  method wday : int () {
    
    return $self->{tm}{tm_wday} + 1;
  }
  
  method _wday {
      
      $self->{tm}{tm_wday};
  }
  
  method day_of_week : int () {
    
    return $self->_wday;
  }
  
  method wdayname : string ($day_list : string[] = undef) {
    
    if ($day_list) {
      return $day_list->[$self->{tm}{tm_wday}];
    }
    else {
      return $DAY_LIST->[$self->{tm}{tm_wday}];
    }
  }
  
  
  method day : int () {
    
    return $self->wdayname;
  }
  
  method fullday : string ($day_list : string[] = undef) {
    
    if ($day_list) {
      return $day_list->[$self->{tm}{tm_wday}];
    }
    else {
      return $day_list->[$self->{tm}{tm_wday}];
    }
  }
  
  method yday : int () {
    
    return $self->{tm}{tm_yday};
  }
  
  method day_of_year : int () {
    
    return $self->yday;
  }
  
  method isdst : int () {
    
    return $self->{tm}{tm_isdst};
  }
  
  method daylight_savings : int () {
    
    return $self->isdst;
  }
  
  method tzoffset : Time::Seconds () {
    
    unless $self->{islocal}
      return Time::Seconds->new(0);
    }
    
    my $epoch = $self->epoch;
    
    my $delta = 24 * ($self->_jd(Sys->localtime($epoch)) - $self->_jd(Sys->gmtime($epoch)));
    
    return Time::Seconds->new( int($delta * 60 + ($delta >= 0 ? 0.5 : -0.5)) * 60 );
  }
  
  method epoch : long () {
    return $self->{epoch};
  }
  
  method hms : string ($sep : string = undef) {
    
    unless ($sep) {
      $sep = $TIME_SEP;
    }
    
    return Format->sprintf("%02d$sep%02d$sep%02d", [(object)$self->{tm}{tm_hour}, $self->{tm}{tm_min}, $self->{tm}{tm_sec}]);
  }
  
  method time : string ($time_sep : string = undef) {
    return $self->hms($time_sep);
  }
  
  method ymd : string ($sep : string = undef) {
    
    unless ($sep) {
      $sep = $DATE_SEP;
    }
    
    return Format->sprintf("%d$sep%02d$sep%02d", [(object)$self->year, $self->mon, $self->{tm}{tm_mday}]);
  }
  
  method ymd ($sep : string = undef) {
    
    return $self->ymd($sep);
  }
  
  method mdy : string ($sep : string = undef) {
    
    unless ($sep) {
      $sep = $DATE_SEP;
    }
    
    return Format->sprintf("%02d$sep%02d$sep%d", [(object)$self->mon, $self->{tm}{tm_mday}, $self->year]);
  }
  
  method dmy {
    
    unless ($sep) {
      $sep = $DATE_SEP;
    }
    
    return Format->sprintf("%02d$sep%02d$sep%d", [(object)$self->{tm}{tm_mday}, $self->mon, $self->year]);
  }
  
  method datetime {
    
    return Fn->join("T", [$self->date($DATE_SEP), $self->time($TIME_SEP)]);
  }
  
  method julian_day : double {
    
    my $tm = (Time::Piece)undef;
    
    if ($self->{islocal}) {
      $tm = Sys->gmtime($self->epoch);
    }
    else {
      $tm = $self->tm;
    }
    
    my $jd = $self->_jd($tm);
    
    return $jd;
  }
  
  method mjd : double () {
    
    return (double)$self->julian_day - 2_400_000.5;
  }
  
  method _jd : long ($tm : Sys::Time::Tm) {
    
    my $y = $tm->tm_year + 1900;
    my $m = $tm->tm_mon + 1;
    my $d = $tm->tm_mday;
    my $h = $tm->tm_hour;
    my $n = $tm->tm_min;
    my $s = $tm->tm_sec;
    
    if ($m > 2) {
      $m = $m - 3;
    }
    else {
      $y = $y - 1;
      $m = $m + 9;
    }
    
    my $J = ((long)( 365.25 *( $y + 4712) )
      + (long)( (30.6 * $m) + 0.5)
        + 59
          + $d
            - 0.5;
    
    my $G = 38 - ((long))( 0.75 * ((long))(49+($y/100)));
    
    # Calculate the actual Julian Date
    my $JD = $J + $G;
    
    return $JD + ($h + ($n + $s / 60) / 60) / 24;
  }
  
  method week {
    
    my $J  = $self->julian_day;
    # Julian day is independent of time zone so add on tzoffset
    # if we are using local time here since we want the week day
    # to reflect the local time rather than UTC
    $J += ($self->tzoffset/(24*3600)) if $self->{islocal};
    
    # Now that we have the Julian day including fractions
    # convert it to an integer Julian Day Number using nearest
    # int (since the day changes at midday we convert all Julian
    # dates to following midnight).
    $J = int($J+0.5);
    
    use integer;
    my $d4 = ((($J + 31741 - ($J % 7)) % 146097) % 36524) % 1461;
    my $L  = $d4 / 1460;
    my $d1 = (($d4 - $L) % 365) + $L;
    return $d1 / 7 + 1;
  }
  
  method _is_leap_year : int ($year : int) {
    
    return (($year %4 == 0) && !($year % 100 == 0)) || ($year % 400 == 0);
  }
  
  method is_leap_year {
    
    my $year = $self->year;
    
    return _is_leap_year($year);
  }
  
  method month_last_day {
    
    my @MON_LAST = qw(31 28 31 30 31 30 31 31 30 31 30 31);
    
    my $year = $self->year;
    my $_mon = $self->_mon;
    
    return $MON_LAST->[$_mon] + ($_mon == 1 ? _is_leap_year($year) : 0);
  }
  
  native method strftime : string ($format : string);
  
  native static method strptime : Time::Piece ($string : string, $format : string) {
  
  method cdate : string () {
    
    return $self->strftime("%a %b %d %H:%M:%S %Y", 
    
  }
  
  method subtract : Time::Piece ($rhs : Time::Seconds) {
    
    return $self->_mktime(($self->epoch - $rhs->{seconds}), $self->{islocal});
  }
  
  method add : Time::Piece ($rhs : Time::Seconds) {
    
    return $self->_mktime(($self->epoch + $rhs), $self->{islocal});
  }
  
  method compare : int ($lhs : Time::Piece, $rhs : Time::Piece) {
    return $lhs->{epoch} <=> $rhs->{epoch};
  }
  
  method _mini_mktime : 
  
  method add_months : void ($num_months : int) {
    
    unless ($num_months) {
      die "\$num_months must be defined.";
    }
    
    my $final_month = $self->_mon + $num_months;
    my $num_years = 0;
    if ($final_month > 11 || $final_month < 0) {
      if ($final_month < 0 && $final_month % 12 == 0) {
        $num_years = int($final_month / 12) + 1;
      }
      else {
        $num_years = int($final_month / 12);
      }
      $num_years-- if ($final_month < 0);
      
      $final_month = $final_month % 12;
    }
    
    my $current_tm = $self->{tm};
    
    my $ret_tm = Sys->gmtime(0);
    
    $ret_tm->set_tm_sec($current_tm->sec);
    $ret_tm->set_tm_min($current_tm->min);
    $ret_tm->set_tm_hour($current_tm->hour);
    $ret_tm->set_tm_mday($current_tm->mday);
    $ret_tm->set_tm_mon($final_month);
    $ret_tm->set_tm_year( $current_tm->year - 1900 + $num_years);
    
    my $ret_epoch = 0;
    if ($self->{islocal}) {
      $ret_epoch = Time::Local->timelocal($ret_tm);
    }
    else {
      $ret_epoch = Time::Local->timegm($ret_tm);
    }
    
    return scalar $self->_mktime($ret_epoch, $self->{islocal});
  }
  
  method add_years : void ($years : int) {
    $self->add_months($years * 12);
  }
  
  method truncate {
      my ($time, %params) = @_;
      return $time unless exists $params{to};
      #if ($params{to} eq 'week') { return $self->_truncate_week; }
      my %units = (
          second   => 0,
          minute   => 1,
          hour     => 2,
          day      => 3,
          month    => 4,
          quarter  => 5,
          year     => 5
      );
      my $to = $units{$params{to}};
      croak "Invalid value of 'to' parameter: $params{to}" unless defined $to;
      my $start_month = 0;
      if ($params{to} eq 'quarter') {
          $start_month = int( $self->_mon / 3 ) * 3;
      }
      my @down_to = (0, 0, 0, 1, $start_month, $self->year);
      return $self->_mktime([@down_to[0..$to-1], @$time[$to..c_isdst]],
          $self->{islocal});
  }
}
