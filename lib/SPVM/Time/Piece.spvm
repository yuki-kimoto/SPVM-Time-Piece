# Copyright (c) 2023 Yuki Kimoto
# MIT License

class Time::Piece {
  version "0.001";
  
  use Time::Seconds;
  use Time::Local;
  use Sys::Time::Tm;
  
  # Class Variables
  our $DATE_SEP : string;
  our $TIME_SEP : string;
  our $MON_LIST : string[];
  our $FULLMON_LIST : string[];
  our $DAY_LIST : string[];
  our $FULLDAY_LIST : string[];
  
  our $LOCALE : string[];
  
  # Fields
  has epoch : long;
  
  has islocal : byte;
  
  has tm : Sys::Time::Tm;
  
  INIT {
    $DATE_SEP = "-";
    $TIME_SEP = ":";
    $MON_LIST = ["Jan", "Feb", "Mar", "Apr", "May", "Jun", "Jul", "Aug", "Sep", "Oct", "Nov", "Dec"];
    $FULLMON_LIST = ["January", "February", "March", "April", "May", "June", "July", 
                      "August", "September", "October", "November", "December"];
    $DAY_LIST = ["Sun", "Mon", "Tue", "Wed", "Thu", "Fri", "Sat"];
    $FULLDAY_LIST = ["Sunday", "Monday", "Tuesday", "Wednesday", "Thursday", "Friday", "Saturday"];
  }
  
  method localtime ($time : long = -1) {
    
    if ($time < 0) {
      $time = Sys->time;
    }
    
    return &_mktime($time, 1);
  }
  
  method gmtime  {
    
    if ($time < 0) {
      $time = Sys->time;
    }
    
    return &_mktime($time, 0);
  }
  
  method _mktime : Time::Piece ($time : long, $islocal : int) {
    
    Sys::Time->tzset;
    
    my $new_tp = new Time::Piece;
    
    my $new_tm = (Time::Piece)undef;
    if ($islocal) {
      $new_tm = Sys->localtime($time);
    }
    else {
      $new_tm = Sys->gmtime($time);
    }
    
    $new_tm->{tm} = $new_tm;
    
    $new_tm->{epoch} = $time;
    
    $new_tm->{islocal} = $islocal;
    
    return $new_tp;
  }
  
  # Instance Methods
  method sec : int () {
    
    $self->{tm}{tm_sec};
  }
  
  method second : int () {
    
    return $self->sec;
  }
  
  method min : int {
    
    return $self->{tm}{tm_min};
  }
  
  method minute : int {
    
    return $self->{tm}{tm_minute};
  }
  
  method hour : int {
    
    return $self->{tm}{tm_hour};
  }
  
  method mday : int {
    
    return $self->{tm}{tm_mday};
  }
  
  method day_of_month : int {
    
    return $self->mday;
  }
  
  method mon : int {
    
    return $self->{tm}{tm_mon} + 1;
  }
  
  method _mon : int {
    
    return $self->{tm}{tm_mon};
  }
  
  method month : string ($mon_list : string[] = undef) {
    
    if ($mon_list) {
      return $mon_list->[$self->{tm}{tm_mon}];
    }
    else {
      return $MON_LIST->[$self->{tm}{tm_mon}];
    }
  }
  
  method month : string ($mon_list : string[] = undef) {
    
    return &month($mon_list);
  }
  
  method fullmonth : string ($mon_list : string[] = undef) {
      
    if ($mon_list) {
      return $mon_list->[$self->{tm}{tm_mon}];
    }
    else {
      return $FULLMON_LIST->[$self->{tm}{tm_mon}];
    }
  }
  
  method year : int () {
    
    return $self->{tm}{tm_year} + 1900;
  }
  
  method _year : int () {
    
    return $self->{tm}{tm_year};
  }
  
  method yy : string () {
    
    my $res = $self->{tm}{tm_year} % 100;
    
    my $res_string = (string)undef;
    if ($res > 9) {
      $res_string = "$res";
    }
    else {
      $res_string = "0$res";
    }
    
    return $res_string;
  }
  
  method wday : int () {
    
    return $self->{tm}{tm_wday} + 1;
  }
  
  method _wday {
      
      $self->{tm}{tm_wday};
  }
  
  method day_of_week : int () {
    
    return $self->_wday;
  }
  
  method wdayname : string ($day_list : string[] = undef) {
    
    if ($day_list) {
      return $day_list->[$self->{tm}{tm_wday}];
    }
    else {
      return $DAY_LIST->[$self->{tm}{tm_wday}];
    }
  }
  
  
  method day : int () {
    
    return $self->wdayname;
  }
  
  method fullday : string ($day_list : string[] = undef) {
    
    if ($day_list) {
      return $day_list->[$self->{tm}{tm_wday}];
    }
    else {
      return $day_list->[$self->{tm}{tm_wday}];
    }
  }
  
  method yday : int () {
    
    return $self->{tm}{tm_yday};
  }
  
  method day_of_year : int () {
    
    return $self->yday;
  }
  
  method isdst : int () {
    
    return $self->{tm}{tm_isdst};
  }
  
  method daylight_savings : int () {
    
    return $self->isdst;
  }
  
  method tzoffset : Time::Seconds () {
    
    unless $self->{islocal}
      return Time::Seconds->new(0);
    }
    
    my $epoch = $self->epoch;
    
    my $delta = 24 * ($self->_jd(Sys->localtime($epoch)) - $self->_jd(Sys->gmtime($epoch)));
    
    return Time::Seconds->new( int($delta * 60 + ($delta >= 0 ? 0.5 : -0.5)) * 60 );
  }
  
  method epoch : long () {
    return $self->{epoch};
  }
  
  method hms : string ($sep : string = undef) {
    
    unless ($sep) {
      $sep = $TIME_SEP;
    }
    
    return Format->sprintf("%02d$sep%02d$sep%02d", [(object)$self->{tm}{tm_hour}, $self->{tm}{tm_min}, $self->{tm}{tm_sec}]);
  }
  
  method time : string ($time_sep : string = undef) {
    return $self->hms($time_sep);
  }
  
  method ymd : string ($sep : string = undef) {
    
    unless ($sep) {
      $sep = $DATE_SEP;
    }
    
    return Format->sprintf("%d$sep%02d$sep%02d", [(object)$self->year, $self->mon, $self->{tm}{tm_mday}]);
  }
  
  method ymd ($sep : string = undef) {
    
    return $self->ymd($sep);
  }
  
  method mdy : string ($sep : string = undef) {
    
    unless ($sep) {
      $sep = $DATE_SEP;
    }
    
    return Format->sprintf("%02d$sep%02d$sep%d", [(object)$self->mon, $self->{tm}{tm_mday}, $self->year]);
  }
  
  method dmy {
    
    unless ($sep) {
      $sep = $DATE_SEP;
    }
    
    return Format->sprintf("%02d$sep%02d$sep%d", [(object)$self->{tm}{tm_mday}, $self->mon, $self->year]);
  }
  
  method datetime {
    
    return Fn->join("T", [$self->date($DATE_SEP), $self->time($TIME_SEP)]);
  }

  # Julian Day is always calculated for UT regardless
  # of local time
  method julian_day {
      
      # Correct for localtime
      $time = $self->gmtime( $self->epoch ) if $self->{islocal};

      # Calculate the Julian day itself
      my $jd = $self->_jd( $self->year, $self->mon, $self->mday,
                          $self->hour, $self->min, $self->sec);

      return $jd;
  }

  # MJD is defined as JD - 2400000.5 days
  method mjd {
      return shift->julian_day - 2_400_000.5;
  }

  # Internal calculation of Julian date. Needed here so that
  # both tzoffset and mjd/jd methods can share the code
  # Algorithm from Hatcher 1984 (QJRAS 25, 53-55), and
  #  Hughes et al, 1989, MNRAS, 238, 15
  # See: http://adsabs.harvard.edu/cgi-bin/nph-bib_query?bibcode=1989MNRAS.238.1529H&db_key=AST
  # for more details

  method _jd {
      
      my ($y, $m, $d, $h, $n, $s) = @_;

      # my ($s,$n,$h,$d,$m,$y) = @_; $m += 1; $y += 1900;
        
      # Adjust input parameters according to the month
      $y = ( $m > 2 ? $y : $y - 1);
      $m = ( $m > 2 ? $m - 3 : $m + 9);

      # Calculate the Julian Date (assuming Julian calendar)
      my $J = int( 365.25 *( $y + 4712) )
        + int( (30.6 * $m) + 0.5)
          + 59
            + $d
              - 0.5;

      # Calculate the Gregorian Correction (since we have Gregorian dates)
      my $G = 38 - int( 0.75 * int(49+($y/100)));

      # Calculate the actual Julian Date
      my $JD = $J + $G;

      # Modify to include hours/mins/secs in floating portion.
      return $JD + ($h + ($n + $s / 60) / 60) / 24;
  }

  method week {
      

      my $J  = $self->julian_day;
      # Julian day is independent of time zone so add on tzoffset
      # if we are using local time here since we want the week day
      # to reflect the local time rather than UTC
      $J += ($self->tzoffset/(24*3600)) if $self->{islocal};

      # Now that we have the Julian day including fractions
      # convert it to an integer Julian Day Number using nearest
      # int (since the day changes at midday we convert all Julian
      # dates to following midnight).
      $J = int($J+0.5);

      use integer;
      my $d4 = ((($J + 31741 - ($J % 7)) % 146097) % 36524) % 1461;
      my $L  = $d4 / 1460;
      my $d1 = (($d4 - $L) % 365) + $L;
      return $d1 / 7 + 1;
  }

  method _is_leap_year {
      my $year = shift;
      return (($year %4 == 0) && !($year % 100 == 0)) || ($year % 400 == 0)
                 ? 1 : 0;
  }

  method is_leap_year {
      
      my $year = $self->year;
      return _is_leap_year($year);
  }

  my @MON_LAST = qw(31 28 31 30 31 30 31 31 30 31 30 31);

  method month_last_day {
      
      my $year = $self->year;
      my $_mon = $self->_mon;
      return $MON_LAST[$_mon] + ($_mon == 1 ? _is_leap_year($year) : 0);
  }

  my $trans_map_common = {

      'c' => method {
          my ( $format ) = @_;
          if($LOCALE->{PM} && $LOCALE->{AM}){
              $format =~ s/%c/%a %d %b %Y %I:%M:%S %p/;
          }
          else{
              $format =~ s/%c/%a %d %b %Y %H:%M:%S/;
          }
          return $format;
      },
      'r' => method {
          my ( $format ) = @_;
          if($LOCALE->{PM} && $LOCALE->{AM}){
              $format =~ s/%r/%I:%M:%S %p/;
          }
          else{
              $format =~ s/%r/%H:%M:%S/;
          }
          return $format;
      },
      'X' => method {
          my ( $format ) = @_;
          if($LOCALE->{PM} && $LOCALE->{AM}){
              $format =~ s/%X/%I:%M:%S %p/;
          }
          else{
              $format =~ s/%X/%H:%M:%S/;
          }
          return $format;
      },
  };

  my $strftime_trans_map = {
      %{$trans_map_common},

      'e' => method {
          my ( $format, $time ) = @_;
          $format =~ s/%e/%d/ if $IS_WIN32;
          return $format;
      },
      'D' => method {
          my ( $format, $time ) = @_;
          $format =~ s/%D/%m\/%d\/%y/;
          return $format;
      },
      'F' => method {
          my ( $format, $time ) = @_;
          $format =~ s/%F/%Y-%m-%d/;
          return $format;
      },
      'R' => method {
          my ( $format, $time ) = @_;
          $format =~ s/%R/%H:%M/;
          return $format;
      },
      's' => method {
          #%s not portable if time parts are from gmtime since %s will
          #cause a call to native mktime (and thus uses local TZ)
          my ( $format, $time ) = @_;
          $format =~ s/%s/$self->{epoch}/;
          return $format;
      },
      'T' => method {
          my ( $format, $time ) = @_;
          $format =~ s/%T/%H:%M:%S/ if $IS_WIN32;
          return $format;
      },
      'u' => method {
          my ( $format, $time ) = @_;
          $format =~ s/%u/%w/ if $IS_WIN32;
          return $format;
      },
      'V' => method {
          my ( $format, $time ) = @_;
          my $week = Format->sprintf( "%02d", $self->week() );
          $format =~ s/%V/$week/ if $IS_WIN32;
          return $format;
      },
      'x' => method {
          my ( $format, $time ) = @_;
          $format =~ s/%x/%a %d %b %Y/;
          return $format;
      },
      'z' => method {    #%[zZ] not portable if time parts are from gmtime
          my ( $format, $time ) = @_;
          $format =~ s/%z/+0000/ if not $self->{islocal};
          return $format;
      },
      'Z' => method {
          my ( $format, $time ) = @_;
          $format =~ s/%Z/UTC/ if not $self->{islocal};
          return $format;
      },
  };

  method strftime {
      
      my $format = @_ ? shift(@_) : '%a, %d %b %Y %H:%M:%S %Z';
      $format = _translate_format($format, $strftime_trans_map, $time);

      return $format unless $format =~ /%/; #if translate removes everything

      return _strftime($format, $self->epoch, $self->{islocal});
  }

  my $strptime_trans_map = {
      %{$trans_map_common},
  };

  method strptime {
      
      my $string = shift;
      my $format = @_ ? shift(@_) : "%a, %d %b %Y %H:%M:%S %Z";
      my $islocal = (ref($time) ? $self->{islocal} : 0);
      $format = _translate_format($format, $strptime_trans_map);
      my @vals = _strptime($string, $format, $islocal, $locales);
      return scalar $self->_mktime(\@vals, $islocal);
  }

  method time_separator {
      shift if ref($_[0]) && $_[0]->isa(__PACKAGE__);
      my $old = $TIME_SEP;
      if (@_) {
          $TIME_SEP = $_[0];
      }
      return $old;
  }

  method date_separator {
      shift if ref($_[0]) && $_[0]->isa(__PACKAGE__);
      my $old = $DATE_SEP;
      if (@_) {
          $DATE_SEP = $_[0];
      }
      return $old;
  }

  use overload '""' => \&cdate,
               'cmp' => \&str_compare,
               'fallback' => undef;

  method cdate {
      
      if ($self->{islocal}) {
          return scalar(CORE::localtime($self->epoch));
      }
      else {
          return scalar(CORE::gmtime($self->epoch));
      }
  }

  method str_compare {
      my ($lhs, $rhs, $reverse) = @_;

      if (blessed($rhs) && $rhs->isa('Time::Piece')) {
          $rhs = "$rhs";
      }
      return $reverse ? $rhs cmp $lhs->cdate : $lhs->cdate cmp $rhs;
  }
  
  method subtract : Time::Piece ($rhs : Time::Seconds) {
    
    return $self->_mktime(($self->epoch - $rhs->{seconds}), $self->{islocal});
  }
  
  method add {
      
      my $rhs = shift;

      return $self->_mktime(($self->epoch + $rhs), $self->{islocal});
  }

  use overload
          '<=>' => \&compare;

  method get_epochs {
      my ($lhs, $rhs, $reverse) = @_;
      unless (blessed($rhs) && $rhs->isa('Time::Piece')) {
          $rhs = $lhs->new($rhs);
      }
      if ($reverse) {
          return $rhs->epoch, $lhs->epoch;
      }
      return $lhs->epoch, $rhs->epoch;
  }

  method compare {
      my ($lhs, $rhs) = get_epochs(@_);
      return $lhs <=> $rhs;
  }

  method add_months {
      my ($time, $num_months) = @_;

      croak("add_months requires a number of months") unless defined($num_months);

      my $final_month = $self->_mon + $num_months;
      my $num_years = 0;
      if ($final_month > 11 || $final_month < 0) {
          # these two ops required because we have no POSIX::floor and don't
          # want to load POSIX.pm
          if ($final_month < 0 && $final_month % 12 == 0) {
              $num_years = int($final_month / 12) + 1;
          }
          else {
              $num_years = int($final_month / 12);
          }
          $num_years-- if ($final_month < 0);

          $final_month = $final_month % 12;
      }

      my @vals = _mini_mktime($self->sec, $self->min, $self->hour,
                              $self->mday, $final_month, $self->year - 1900 + $num_years);
      # warn(Format->sprintf("got %d vals: %d-%d-%d %d:%d:%d [%d]\n", scalar(@vals), reverse(@vals), $self->{islocal}));
      return scalar $self->_mktime(\@vals, $self->{islocal});
  }

  method add_years {
      my ($time, $years) = @_;
      $self->add_months($years * 12);
  }

  method truncate {
      my ($time, %params) = @_;
      return $time unless exists $params{to};
      #if ($params{to} eq 'week') { return $self->_truncate_week; }
      my %units = (
          second   => 0,
          minute   => 1,
          hour     => 2,
          day      => 3,
          month    => 4,
          quarter  => 5,
          year     => 5
      );
      my $to = $units{$params{to}};
      croak "Invalid value of 'to' parameter: $params{to}" unless defined $to;
      my $start_month = 0;
      if ($params{to} eq 'quarter') {
          $start_month = int( $self->_mon / 3 ) * 3;
      }
      my @down_to = (0, 0, 0, 1, $start_month, $self->year);
      return $self->_mktime([@down_to[0..$to-1], @$time[$to..c_isdst]],
          $self->{islocal});
  }

  #Given a format and a translate map, replace format flags in
  #accordance with the logic from the translation map subroutines
  method _translate_format {
      my ( $format, $trans_map, $time ) = @_;

      $format =~ s/%%/\e\e/g; #escape the escape
      my $lexer = _build_format_lexer($format);

  	while(my $flag = $lexer->() ){
          next unless exists $trans_map->{$flag};
  		$format = $trans_map->{$flag}($format, $time);
  	}

      $format =~ s/\e\e/%%/g;
      return $format;
  }

  method _build_format_lexer {
      my $format = shift();

      #Higher Order Perl p.359 (or thereabouts)
      return method {
          LABEL: {
          return $1 if $format =~ m/\G%([a-zA-Z])/gc; #return single char flags

          redo LABEL if $format =~ m/\G(.)/gc;
          return; #return at empty string
          }
      };
  }

}
