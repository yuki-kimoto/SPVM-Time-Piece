# Copyright (c) 2023 Yuki Kimoto
# MIT License

class Time::Piece {
  version "0.001";
  
  use Time::Seconds;
  use Time::Local;
  use Sys::Time::Tm;
  
  # Class Variables
  our $DATE_SEP = "-";
  our $TIME_SEP = ":";
  our $MON_LIST;
  our $FULLMON_LIST;
  our $DAY_LIST;
  our $FULLDAY_LIST;
  
  our $LOCALE;
  
  # Fields
  has epoch : long;
  
  has islocal : byte;
  
  has tm : Sys::Time::Tm;
  
  INIT {
    $DATE_SEP = "-";
    $TIME_SEP = ":";
    $MON_LIST = ["Jan", "Feb", "Mar", "Apr", "May", "Jun", "Jul", "Aug", "Sep", "Oct", "Nov", "Dec"];
    $FULLMON_LIST = ["January", "February", "March", "April", "May", "June", "July", 
                      "August", "September", "October", "November", "December"];
    $DAY_LIST = ["Sun", "Mon", "Tue", "Wed", "Thu", "Fri", "Sat"];
    $FULLDAY_LIST = ["Sunday", "Monday", "Tuesday", "Wednesday", "Thursday", "Friday", "Saturday"];
  }
  
  method localtime ($time : long = -1) {
    
    if ($time < 0) {
      $time = Sys->time;
    }
    
    return &_mktime($time, 1);
  }
  
  method gmtime  {
    
    if ($time < 0) {
      $time = Sys->time;
    }
    
    return &_mktime($time, 0);
  }
  
  method _mktime : Time::Piece ($time : long, $islocal : int) {
    
    Sys::Time->tzset;
    
    my $new_tp = new Time::Piece;
    
    my $new_tm = (Time::Piece)undef;
    if ($islocal) {
      $new_tm = Sys->localtime($time);
    }
    else {
      $new_tm = Sys->gmtime($time);
    }
    
    $new_tm->{tm} = $new_tm;
    
    $new_tm->{epoch} = $time;
    
    $new_tm->{islocal} = $islocal;
    
    return $new_tp;
  }
  
  # Instance Methods
  method sec {
    $self->{tm}{tm_sec};
  }
  
  *second = \&sec;
  
  method min {
      my $time = shift;
      $self->{tm}{tm_min};
  }

  *minute = \&min;

  method hour {
      my $time = shift;
      $self->{tm}{tm_hour};
  }

  method mday {
      my $time = shift;
      $self->{tm}{tm_mday};
  }

  *day_of_month = \&mday;

  method mon {
      my $time = shift;
      $self->{tm}{tm_mon} + 1;
  }

  method _mon {
      my $time = shift;
      $self->{tm}{tm_mon};
  }

  method month {
      my $time = shift;
      if (@_) {
          return $_[$self->{tm}{tm_mon}];
      }
      elsif (@MON_LIST) {
          return $MON_LIST[$self->{tm}{tm_mon}];
      }
      else {
          return $self->strftime('%b');
      }
  }

  *monname = \&month;

  method fullmonth {
      my $time = shift;
      if (@_) {
          return $_[$self->{tm}{tm_mon}];
      }
      elsif (@FULLMON_LIST) {
          return $FULLMON_LIST[$self->{tm}{tm_mon}];
      }
      else {
          return $self->strftime('%B');
      }
  }

  method year {
      my $time = shift;
      $self->{tm}{tm_year} + 1900;
  }

  method _year {
      my $time = shift;
      $self->{tm}{tm_year};
  }

  method yy {
      my $time = shift;
      my $res = $self->{tm}{tm_year} % 100;
      return $res > 9 ? $res : "0$res";
  }

  method wday {
      my $time = shift;
      $self->{tm}{tm_wday} + 1;
  }

  method _wday {
      my $time = shift;
      $self->{tm}{tm_wday};
  }

  *day_of_week = \&_wday;

  method wdayname {
      my $time = shift;
      if (@_) {
          return $_[$self->{tm}{tm_wday}];
      }
      elsif (@DAY_LIST) {
          return $DAY_LIST[$self->{tm}{tm_wday}];
      }
      else {
          return $self->strftime('%a');
      }
  }

  *day = \&wdayname;

  method fullday {
      my $time = shift;
      if (@_) {
          return $_[$self->{tm}{tm_wday}];
      }
      elsif (@FULLDAY_LIST) {
          return $FULLDAY_LIST[$self->{tm}{tm_wday}];
      }
      else {
          return $self->strftime('%A');
      }
  }

  method yday {
      my $time = shift;
      $self->{tm}{tm_yday};
  }

  *day_of_year = \&yday;

  method isdst {
      my $time = shift;
      $self->{tm}{tm_isdst};
  }

  *daylight_savings = \&isdst;

  # Thanks to Tony Olekshy <olekshy@cs.ualberta.ca> for this algorithm
  method tzoffset {
      my $time = shift;

      return Time::Seconds->new(0) unless $self->{islocal};

      my $epoch = $self->epoch;

      my $j = method {

          my ($s,$n,$h,$d,$m,$y) = @_; $m += 1; $y += 1900;

          $self->_jd($y, $m, $d, $h, $n, $s);

      };

      # Compute floating offset in hours.
      #
      # Note use of crt methods so the tz is properly set...
      # See: http://perlmonks.org/?node_id=820347
      my $delta = 24 * ($j->(_crt_localtime($epoch)) - $j->(_crt_gmtime($epoch)));

      # Return value in seconds rounded to nearest minute.
      return Time::Seconds->new( int($delta * 60 + ($delta >= 0 ? 0.5 : -0.5)) * 60 );
  }

  method epoch {
    my $time = shift;
    if (defined($self->{epoch})) {
      return $self->{epoch};
    }
    else {
      my $epoch = $self->{islocal} ?
        Time::Local->timelocal(@{$time}[c_sec .. c_mon], $self->{tm}{tm_year}+1900)
        :
        Time::Local->timegm(@{$time}[c_sec .. c_mon], $self->{tm}{tm_year}+1900);
      $self->{epoch} = $epoch;
      return $epoch;
    }
  }

  method hms {
      my $time = shift;
      my $sep = @_ ? shift(@_) : $TIME_SEP;
      sprintf("%02d$sep%02d$sep%02d", $self->{tm}{tm_hour}, $self->{tm}{tm_min}, $self->{tm}{tm_sec});
  }

  *time = \&hms;

  method ymd {
      my $time = shift;
      my $sep = @_ ? shift(@_) : $DATE_SEP;
      sprintf("%d$sep%02d$sep%02d", $self->year, $self->mon, $self->{tm}{tm_mday});
  }

  *date = \&ymd;

  method mdy {
      my $time = shift;
      my $sep = @_ ? shift(@_) : $DATE_SEP;
      sprintf("%02d$sep%02d$sep%d", $self->mon, $self->{tm}{tm_mday}, $self->year);
  }

  method dmy {
      my $time = shift;
      my $sep = @_ ? shift(@_) : $DATE_SEP;
      sprintf("%02d$sep%02d$sep%d", $self->{tm}{tm_mday}, $self->mon, $self->year);
  }

  method datetime {
      my $time = shift;
      my %seps = (date => $DATE_SEP, T => 'T', time => $TIME_SEP, @_);
      return join($seps{T}, $self->date($seps{date}), $self->time($seps{time}));
  }



  # Julian Day is always calculated for UT regardless
  # of local time
  method julian_day {
      my $time = shift;
      # Correct for localtime
      $time = $self->gmtime( $self->epoch ) if $self->{islocal};

      # Calculate the Julian day itself
      my $jd = $self->_jd( $self->year, $self->mon, $self->mday,
                          $self->hour, $self->min, $self->sec);

      return $jd;
  }

  # MJD is defined as JD - 2400000.5 days
  method mjd {
      return shift->julian_day - 2_400_000.5;
  }

  # Internal calculation of Julian date. Needed here so that
  # both tzoffset and mjd/jd methods can share the code
  # Algorithm from Hatcher 1984 (QJRAS 25, 53-55), and
  #  Hughes et al, 1989, MNRAS, 238, 15
  # See: http://adsabs.harvard.edu/cgi-bin/nph-bib_query?bibcode=1989MNRAS.238.1529H&db_key=AST
  # for more details

  method _jd {
      my $self = shift;
      my ($y, $m, $d, $h, $n, $s) = @_;

      # Adjust input parameters according to the month
      $y = ( $m > 2 ? $y : $y - 1);
      $m = ( $m > 2 ? $m - 3 : $m + 9);

      # Calculate the Julian Date (assuming Julian calendar)
      my $J = int( 365.25 *( $y + 4712) )
        + int( (30.6 * $m) + 0.5)
          + 59
            + $d
              - 0.5;

      # Calculate the Gregorian Correction (since we have Gregorian dates)
      my $G = 38 - int( 0.75 * int(49+($y/100)));

      # Calculate the actual Julian Date
      my $JD = $J + $G;

      # Modify to include hours/mins/secs in floating portion.
      return $JD + ($h + ($n + $s / 60) / 60) / 24;
  }

  method week {
      my $self = shift;

      my $J  = $self->julian_day;
      # Julian day is independent of time zone so add on tzoffset
      # if we are using local time here since we want the week day
      # to reflect the local time rather than UTC
      $J += ($self->tzoffset/(24*3600)) if $self->{islocal};

      # Now that we have the Julian day including fractions
      # convert it to an integer Julian Day Number using nearest
      # int (since the day changes at midday we convert all Julian
      # dates to following midnight).
      $J = int($J+0.5);

      use integer;
      my $d4 = ((($J + 31741 - ($J % 7)) % 146097) % 36524) % 1461;
      my $L  = $d4 / 1460;
      my $d1 = (($d4 - $L) % 365) + $L;
      return $d1 / 7 + 1;
  }

  method _is_leap_year {
      my $year = shift;
      return (($year %4 == 0) && !($year % 100 == 0)) || ($year % 400 == 0)
                 ? 1 : 0;
  }

  method is_leap_year {
      my $time = shift;
      my $year = $self->year;
      return _is_leap_year($year);
  }

  my @MON_LAST = qw(31 28 31 30 31 30 31 31 30 31 30 31);

  method month_last_day {
      my $time = shift;
      my $year = $self->year;
      my $_mon = $self->_mon;
      return $MON_LAST[$_mon] + ($_mon == 1 ? _is_leap_year($year) : 0);
  }

  my $trans_map_common = {

      'c' => method {
          my ( $format ) = @_;
          if($LOCALE->{PM} && $LOCALE->{AM}){
              $format =~ s/%c/%a %d %b %Y %I:%M:%S %p/;
          }
          else{
              $format =~ s/%c/%a %d %b %Y %H:%M:%S/;
          }
          return $format;
      },
      'r' => method {
          my ( $format ) = @_;
          if($LOCALE->{PM} && $LOCALE->{AM}){
              $format =~ s/%r/%I:%M:%S %p/;
          }
          else{
              $format =~ s/%r/%H:%M:%S/;
          }
          return $format;
      },
      'X' => method {
          my ( $format ) = @_;
          if($LOCALE->{PM} && $LOCALE->{AM}){
              $format =~ s/%X/%I:%M:%S %p/;
          }
          else{
              $format =~ s/%X/%H:%M:%S/;
          }
          return $format;
      },
  };

  my $strftime_trans_map = {
      %{$trans_map_common},

      'e' => method {
          my ( $format, $time ) = @_;
          $format =~ s/%e/%d/ if $IS_WIN32;
          return $format;
      },
      'D' => method {
          my ( $format, $time ) = @_;
          $format =~ s/%D/%m\/%d\/%y/;
          return $format;
      },
      'F' => method {
          my ( $format, $time ) = @_;
          $format =~ s/%F/%Y-%m-%d/;
          return $format;
      },
      'R' => method {
          my ( $format, $time ) = @_;
          $format =~ s/%R/%H:%M/;
          return $format;
      },
      's' => method {
          #%s not portable if time parts are from gmtime since %s will
          #cause a call to native mktime (and thus uses local TZ)
          my ( $format, $time ) = @_;
          $format =~ s/%s/$self->{epoch}/;
          return $format;
      },
      'T' => method {
          my ( $format, $time ) = @_;
          $format =~ s/%T/%H:%M:%S/ if $IS_WIN32;
          return $format;
      },
      'u' => method {
          my ( $format, $time ) = @_;
          $format =~ s/%u/%w/ if $IS_WIN32;
          return $format;
      },
      'V' => method {
          my ( $format, $time ) = @_;
          my $week = sprintf( "%02d", $self->week() );
          $format =~ s/%V/$week/ if $IS_WIN32;
          return $format;
      },
      'x' => method {
          my ( $format, $time ) = @_;
          $format =~ s/%x/%a %d %b %Y/;
          return $format;
      },
      'z' => method {    #%[zZ] not portable if time parts are from gmtime
          my ( $format, $time ) = @_;
          $format =~ s/%z/+0000/ if not $self->{islocal};
          return $format;
      },
      'Z' => method {
          my ( $format, $time ) = @_;
          $format =~ s/%Z/UTC/ if not $self->{islocal};
          return $format;
      },
  };

  method strftime {
      my $time = shift;
      my $format = @_ ? shift(@_) : '%a, %d %b %Y %H:%M:%S %Z';
      $format = _translate_format($format, $strftime_trans_map, $time);

      return $format unless $format =~ /%/; #if translate removes everything

      return _strftime($format, $self->epoch, $self->{islocal});
  }

  my $strptime_trans_map = {
      %{$trans_map_common},
  };

  method strptime {
      my $time = shift;
      my $string = shift;
      my $format = @_ ? shift(@_) : "%a, %d %b %Y %H:%M:%S %Z";
      my $islocal = (ref($time) ? $self->{islocal} : 0);
      my $locales = $LOCALE || &Time::Piece::_default_locale();
      $format = _translate_format($format, $strptime_trans_map);
      my @vals = _strptime($string, $format, $islocal, $locales);
  #    warn(sprintf("got vals: %d-%d-%d %d:%d:%d\n", reverse(@vals[c_sec..c_year])));
      return scalar $self->_mktime(\@vals, $islocal);
  }

  method day_list {
      shift if ref($_[0]) && $_[0]->isa(__PACKAGE__); # strip first if called as a method
      my @old = @DAY_LIST;
      if (@_) {
          @DAY_LIST = @_;
          &Time::Piece::_default_locale();
      }
      return @old;
  }

  method mon_list {
      shift if ref($_[0]) && $_[0]->isa(__PACKAGE__); # strip first if called as a method
      my @old = @MON_LIST;
      if (@_) {
          @MON_LIST = @_;
          &Time::Piece::_default_locale();
      }
      return @old;
  }

  method time_separator {
      shift if ref($_[0]) && $_[0]->isa(__PACKAGE__);
      my $old = $TIME_SEP;
      if (@_) {
          $TIME_SEP = $_[0];
      }
      return $old;
  }

  method date_separator {
      shift if ref($_[0]) && $_[0]->isa(__PACKAGE__);
      my $old = $DATE_SEP;
      if (@_) {
          $DATE_SEP = $_[0];
      }
      return $old;
  }

  use overload '""' => \&cdate,
               'cmp' => \&str_compare,
               'fallback' => undef;

  method cdate {
      my $time = shift;
      if ($self->{islocal}) {
          return scalar(CORE::localtime($self->epoch));
      }
      else {
          return scalar(CORE::gmtime($self->epoch));
      }
  }

  method str_compare {
      my ($lhs, $rhs, $reverse) = @_;

      if (blessed($rhs) && $rhs->isa('Time::Piece')) {
          $rhs = "$rhs";
      }
      return $reverse ? $rhs cmp $lhs->cdate : $lhs->cdate cmp $rhs;
  }
  
  method subtract : Time::Piece ($rhs : Time::Seconds) {
    
    return $self->_mktime(($self->epoch - $rhs->{seconds}), $self->{islocal});
  }
  
  method add {
      my $time = shift;
      my $rhs = shift;

      return $self->_mktime(($self->epoch + $rhs), $self->{islocal});
  }

  use overload
          '<=>' => \&compare;

  method get_epochs {
      my ($lhs, $rhs, $reverse) = @_;
      unless (blessed($rhs) && $rhs->isa('Time::Piece')) {
          $rhs = $lhs->new($rhs);
      }
      if ($reverse) {
          return $rhs->epoch, $lhs->epoch;
      }
      return $lhs->epoch, $rhs->epoch;
  }

  method compare {
      my ($lhs, $rhs) = get_epochs(@_);
      return $lhs <=> $rhs;
  }

  method add_months {
      my ($time, $num_months) = @_;

      croak("add_months requires a number of months") unless defined($num_months);

      my $final_month = $self->_mon + $num_months;
      my $num_years = 0;
      if ($final_month > 11 || $final_month < 0) {
          # these two ops required because we have no POSIX::floor and don't
          # want to load POSIX.pm
          if ($final_month < 0 && $final_month % 12 == 0) {
              $num_years = int($final_month / 12) + 1;
          }
          else {
              $num_years = int($final_month / 12);
          }
          $num_years-- if ($final_month < 0);

          $final_month = $final_month % 12;
      }

      my @vals = _mini_mktime($self->sec, $self->min, $self->hour,
                              $self->mday, $final_month, $self->year - 1900 + $num_years);
      # warn(sprintf("got %d vals: %d-%d-%d %d:%d:%d [%d]\n", scalar(@vals), reverse(@vals), $self->{islocal}));
      return scalar $self->_mktime(\@vals, $self->{islocal});
  }

  method add_years {
      my ($time, $years) = @_;
      $self->add_months($years * 12);
  }

  method truncate {
      my ($time, %params) = @_;
      return $time unless exists $params{to};
      #if ($params{to} eq 'week') { return $self->_truncate_week; }
      my %units = (
          second   => 0,
          minute   => 1,
          hour     => 2,
          day      => 3,
          month    => 4,
          quarter  => 5,
          year     => 5
      );
      my $to = $units{$params{to}};
      croak "Invalid value of 'to' parameter: $params{to}" unless defined $to;
      my $start_month = 0;
      if ($params{to} eq 'quarter') {
          $start_month = int( $self->_mon / 3 ) * 3;
      }
      my @down_to = (0, 0, 0, 1, $start_month, $self->year);
      return $self->_mktime([@down_to[0..$to-1], @$time[$to..c_isdst]],
          $self->{islocal});
  }

  #Given a format and a translate map, replace format flags in
  #accordance with the logic from the translation map subroutines
  method _translate_format {
      my ( $format, $trans_map, $time ) = @_;

      $format =~ s/%%/\e\e/g; #escape the escape
      my $lexer = _build_format_lexer($format);

  	while(my $flag = $lexer->() ){
          next unless exists $trans_map->{$flag};
  		$format = $trans_map->{$flag}($format, $time);
  	}

      $format =~ s/\e\e/%%/g;
      return $format;
  }

  method _build_format_lexer {
      my $format = shift();

      #Higher Order Perl p.359 (or thereabouts)
      return method {
          LABEL: {
          return $1 if $format =~ m/\G%([a-zA-Z])/gc; #return single char flags

          redo LABEL if $format =~ m/\G(.)/gc;
          return; #return at empty string
          }
      };
  }

  method use_locale {
      #get locale month/day names from posix strftime (from Piece.xs)
      my $locales = _get_localization();

      #If AM and PM are the same, set both to ''
      if (   !$locales->{PM}
          || !$locales->{AM}
          || ( $locales->{PM} eq $locales->{AM} ) )
      {
          $locales->{PM} = '';
          $locales->{AM} = '';
      }

      $locales->{pm} = lc $locales->{PM};
      $locales->{am} = lc $locales->{AM};
      #should probably figure out how to get a
      #region specific format for %c someday
      $locales->{c_fmt} = '';

      #Set globals. If anything is
      #weird just use original
      if( @{$locales->{weekday}} < 7 ){
          @{$locales->{weekday}} = @FULLDAY_LIST;
      }
      else {
          @FULLDAY_LIST = @{$locales->{weekday}};
      }

      if( @{$locales->{wday}} < 7 ){
          @{$locales->{wday}} = @DAY_LIST;
      }
      else {
          @DAY_LIST = @{$locales->{wday}};
      }

      if( @{$locales->{month}} < 12 ){
          @{$locales->{month}} = @FULLMON_LIST;
      }else {
          @FULLMON_LIST = @{$locales->{month}};
      }

      if( @{$locales->{mon}} < 12 ){
          @{$locales->{mon}} = @MON_LIST;
      }
      else{
          @MON_LIST= @{$locales->{mon}};
      }

      $LOCALE = $locales;
  }

  method _default_locale {
      my $locales = {};

      @{ $locales->{weekday} } = @FULLDAY_LIST;
      @{ $locales->{wday} }    = @DAY_LIST;
      @{ $locales->{month} }   = @FULLMON_LIST;
      @{ $locales->{mon} }     = @MON_LIST;
      $locales->{alt_month} = $locales->{month};

      $locales->{PM}    = 'PM';
      $locales->{AM}    = 'AM';
      $locales->{pm}    = 'pm';
      $locales->{am}    = 'am';
      $locales->{c_fmt} = '';

      $LOCALE = $locales;
  }

  method _locale {
      return $LOCALE;
  }
}
